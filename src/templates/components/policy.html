<div class="policy-content">
    <div class="policy-header">
        <span>Data Metrics</span>
        <select id="metric-select" class="metric-select">
            <option value="land_degradation">Land Degradation</option>
            <option value="soil_organic_carbon">Soil Organic Carbon</option>
            <option value="vegetation_cover">Vegetation Cover</option>
            <option value="biodiversity_index">Biodiversity Index</option>
        </select>
    </div>
    <div class="metric-info">
        <div id="metric-description"></div>
        <div id="metric-unit"></div>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const metricSelect = document.getElementById('metric-select');
    
    // Initialize with default metric
    const defaultMetric = 'land_degradation';
    
    // Wait for map to be initialized
    if (!window.map) {
        window.addEventListener('mapInitialized', () => {
            updateMetricInfo(defaultMetric);
            updateMapMetric(defaultMetric);
        });
    } else {
        updateMetricInfo(defaultMetric);
        updateMapMetric(defaultMetric);
    }
    
    // Add event listener for metric changes
    metricSelect.addEventListener('change', function(e) {
        const selectedMetric = e.target.value;
        updateMapMetric(selectedMetric);
    });
});

function updateMapMetric(metricId) {
    if (!window.map) {
        console.error('Map not initialized');
        return;
    }

    // Get the source
    const source = map.getSource('h3-hexagons');
    if (!source) {
        console.error('h3-hexagons source not found');
        return;
    }

    // Get current data
    const data = source._data;
    if (!data || !data.features) {
        console.error('No data in source');
        return;
    }

    // Find min and max values for normalization
    let minValue = Infinity;
    let maxValue = -Infinity;
    
    data.features.forEach(feature => {
        const metrics = typeof feature.properties.metrics === 'string' 
            ? JSON.parse(feature.properties.metrics) 
            : feature.properties.metrics;
            
        if (metrics && metrics[metricId] !== undefined) {
            const value = parseFloat(metrics[metricId]);
            if (!isNaN(value)) {
                minValue = Math.min(minValue, value);
                maxValue = Math.max(maxValue, value);
            }
        }
    });

    // Update features with new colors based on selected metric
    const updatedFeatures = data.features.map(feature => {
        const metrics = typeof feature.properties.metrics === 'string' 
            ? JSON.parse(feature.properties.metrics) 
            : feature.properties.metrics;
            
        if (metrics && metrics[metricId] !== undefined) {
            const value = parseFloat(metrics[metricId]);
            if (!isNaN(value)) {
                // Normalize value between 0 and 1
                const normalizedValue = (maxValue === minValue) 
                    ? 0.5 // If all values are the same, use middle color
                    : (value - minValue) / (maxValue - minValue);
                
                const [startColor, endColor] = getMetricColorScale(metricId);
                feature.properties.color = interpolateColor(startColor, endColor, normalizedValue);
            }
        }
        return feature;
    });

    // Update the source data
    source.setData({
        type: 'FeatureCollection',
        features: updatedFeatures
    });

    // Update popup handling
    map.off('mousemove', 'h3-hexagons-fill');
    map.off('mouseleave', 'h3-hexagons-fill');

    map.on('mousemove', 'h3-hexagons-fill', (e) => {
        if (e.features && e.features.length > 0) {
            const feature = e.features[0];
            if (!feature.properties || !feature.properties.metrics) {
                console.error('No metrics found in feature:', feature);
                return;
            }

            try {
                // Safely parse metrics if it's a string
                const metrics = typeof feature.properties.metrics === 'string' 
                    ? JSON.parse(feature.properties.metrics) 
                    : feature.properties.metrics;
                
                // Safely get the value
                const value = metrics[metricId];
                if (value === undefined || value === null) {
                    console.warn(`No value found for metric: ${metricId}`);
                    return;
                }

                // Format the value
                const unit = getMetricUnit(metricId);
                const formattedValue = typeof value === 'number' 
                    ? Number(value).toFixed(2) 
                    : value.toString();
                
                // Create and show popup
                popup
                    .setLngLat(e.lngLat)
                    .setHTML(`
                        <div class="popup-content">
                            <h4>${metricId.split('_').map(word => 
                                word.charAt(0).toUpperCase() + word.slice(1)
                            ).join(' ')}</h4>
                            <p>Value: ${formattedValue} ${unit}</p>
                        </div>
                    `)
                    .addTo(map);
            } catch (error) {
                console.error('Error processing feature metrics:', error);
                popup.remove();
            }
        }
    });

    map.on('mouseleave', 'h3-hexagons-fill', () => {
        popup.remove();
    });

    // Update legend
    updateLegend(metricId);
}

function updateLegend(metricId) {
    const [startColor, endColor] = getMetricColorScale(metricId);
    const legendGradient = document.getElementById('legend-gradient-bar');
    const legendTitle = document.getElementById('legend-title');
    
    if (legendGradient) {
        legendGradient.style.background = `linear-gradient(to right, ${startColor}, ${endColor})`;
    }
    
    if (legendTitle) {
        legendTitle.textContent = metricId.split('_')
            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
            .join(' ');
    }
}

function interpolateColor(startColor, endColor, ratio) {
    // Ensure ratio is between 0 and 1
    ratio = Math.max(0, Math.min(1, ratio));
    
    // Convert hex to RGB
    const start = hexToRgb(startColor);
    const end = hexToRgb(endColor);
    
    if (!start || !end) {
        console.error('Invalid color values:', startColor, endColor);
        return '#ff0000'; // Fallback to red if colors are invalid
    }
    
    // Interpolate each component
    const r = Math.round(start.r + (end.r - start.r) * ratio);
    const g = Math.round(start.g + (end.g - start.g) * ratio);
    const b = Math.round(start.b + (end.b - start.b) * ratio);
    
    // Convert back to hex
    return rgbToHex(r, g, b);
}

function hexToRgb(hex) {
    // Remove # if present
    hex = hex.replace(/^#/, '');
    
    // Parse hex values
    const bigint = parseInt(hex, 16);
    if (isNaN(bigint)) {
        console.error('Invalid hex color:', hex);
        return null;
    }
    
    return {
        r: (bigint >> 16) & 255,
        g: (bigint >> 8) & 255,
        b: bigint & 255
    };
}

function rgbToHex(r, g, b) {
    // Ensure values are within valid range
    r = Math.max(0, Math.min(255, r));
    g = Math.max(0, Math.min(255, g));
    b = Math.max(0, Math.min(255, b));
    
    // Convert to hex and pad with zeros if needed
    const hex = ((r << 16) | (g << 8) | b).toString(16).padStart(6, '0');
    return `#${hex}`;
}

function getMetricColorScale(metricId) {
    const colorScales = {
        'land_degradation': ['#2ecc71', '#e74c3c'],
        'soil_organic_carbon': ['#fff7fb', '#023858'],
        'vegetation_cover': ['#ffffe5', '#004529'],
        'biodiversity_index': ['#ffffcc', '#800026']
    };
    return colorScales[metricId] || ['#ffffff', '#000000'];
}

function getMetricMaxValue(metricId) {
    const maxValues = {
        'land_degradation': 1,
        'soil_organic_carbon': 150,
        'vegetation_cover': 100,
        'biodiversity_index': 10
    };
    return maxValues[metricId] || 1;
}

function updateMetricInfo(metricId) {
    const descriptions = {
        'land_degradation': 'Degree of land degradation (0-1)',
        'soil_organic_carbon': 'Soil organic carbon content (tons/ha)',
        'vegetation_cover': 'Percentage of vegetation cover (%)',
        'biodiversity_index': 'Species diversity index (0-10)'
    };
    
    const units = {
        'land_degradation': 'index',
        'soil_organic_carbon': 'tons/ha',
        'vegetation_cover': '%',
        'biodiversity_index': 'index'
    };
    
    const descriptionElement = document.getElementById('metric-description');
    const unitElement = document.getElementById('metric-unit');
    
    if (descriptionElement) {
        descriptionElement.textContent = descriptions[metricId] || '';
    }
    if (unitElement) {
        unitElement.textContent = `Unit: ${units[metricId] || ''}`;
    }
}

function getMetricUnit(metricId) {
    const units = {
        'land_degradation': 'index',
        'soil_organic_carbon': 'tons/ha',
        'vegetation_cover': '%',
        'biodiversity_index': 'index'
    };
    return units[metricId] || '';
}

// Add this helper function to get metric ranges
function getMetricRange(metricId) {
    const ranges = {
        'land_degradation': [0, 1],
        'soil_organic_carbon': [0, 150],
        'vegetation_cover': [0, 100],
        'biodiversity_index': [0, 10]
    };
    return ranges[metricId] || [0, 1];
}
</script> 